# MBTI测试数据分析体系

## 1. 数据分析架构

### 1.1 数据收集体系

#### 前端埋点设计
```javascript
// 页面访问埋点
const trackPageView = (pageName, referrer) => {
  analytics.track('page_view', {
    page_name: pageName,
    referrer: referrer,
    timestamp: Date.now(),
    session_id: getSessionId(),
    user_id: getUserId(),
    device_type: getDeviceType(),
    utm_source: getUrlParam('utm_source'),
    utm_medium: getUrlParam('utm_medium'),
    utm_campaign: getUrlParam('utm_campaign')
  });
};

// 用户行为埋点
const trackUserAction = (action, category, label, value) => {
  analytics.track('user_action', {
    action: action,
    category: category,
    label: label,
    value: value,
    page_url: window.location.href,
    timestamp: Date.now(),
    session_duration: getSessionDuration()
  });
};

// 转化节点埋点
const trackConversion = (step, status, metadata) => {
  analytics.track('conversion', {
    funnel_step: step,
    status: status,
    metadata: metadata,
    user_type: getUserType(),
    session_id: getSessionId()
  });
};
```

#### 关键埋点列表
```
【页面级埋点】
- 首页访问：记录来源、停留时间
- 测试页面：记录进度、答题时长
- 结果页面：记录查看时长、滚动深度
- 支付页面：记录停留时间、退出原因

【行为级埋点】
- 开始测试：点击按钮时间、用户状态
- 答题行为：每题答题时长、选项分布
- 分享行为：分享平台、分享时间
- 支付行为：支付方式、支付结果

【业务级埋点】
- 用户注册：注册来源、注册方式
- 测试完成：测试类型、完成时长
- 内容解锁：解锁内容、解锁时间
- 用户流失：流失节点、流失原因
```

### 1.2 数据存储架构

#### 数据分层设计
```
【原始数据层】（Raw Data）
- 用户行为日志
- 业务操作记录
- 系统监控数据
- 第三方数据接入

【清洗数据层】（Clean Data）
- 数据去重和清洗
- 数据格式标准化
- 异常数据过滤
- 数据质量检查

【汇总数据层】（Aggregated Data）
- 按时间维度汇总
- 按用户维度汇总
- 按渠道维度汇总
- 按产品功能汇总

【应用数据层】（Application Data）
- 实时监控数据
- 报表分析数据
- 机器学习特征
- API接口数据
```

#### 数据模型设计
```sql
-- 用户行为事实表
CREATE TABLE fact_user_behavior (
    id BIGINT PRIMARY KEY,
    user_id VARCHAR(32),
    session_id VARCHAR(32),
    event_type VARCHAR(50),
    event_name VARCHAR(100),
    page_url TEXT,
    referrer TEXT,
    device_type VARCHAR(20),
    utm_source VARCHAR(50),
    utm_medium VARCHAR(50),
    utm_campaign VARCHAR(50),
    properties JSON,
    created_at TIMESTAMP,
    INDEX idx_user_time (user_id, created_at),
    INDEX idx_event_time (event_type, created_at),
    INDEX idx_session (session_id)
);

-- 转化漏斗事实表
CREATE TABLE fact_conversion_funnel (
    id BIGINT PRIMARY KEY,
    user_id VARCHAR(32),
    session_id VARCHAR(32),
    funnel_name VARCHAR(50),
    step_name VARCHAR(50),
    step_order INT,
    step_status ENUM('enter', 'exit', 'convert'),
    step_duration INT,
    metadata JSON,
    created_at TIMESTAMP,
    INDEX idx_user_funnel (user_id, funnel_name, created_at),
    INDEX idx_step_time (step_name, created_at)
);

-- 用户维度表
CREATE TABLE dim_user (
    user_id VARCHAR(32) PRIMARY KEY,
    registration_date DATE,
    first_test_date DATE,
    first_payment_date DATE,
    mbti_type VARCHAR(4),
    age_group VARCHAR(10),
    gender VARCHAR(10),
    city VARCHAR(50),
    registration_source VARCHAR(50),
    user_status ENUM('active', 'inactive', 'churned'),
    updated_at TIMESTAMP
);

-- 内容消费事实表
CREATE TABLE fact_content_consumption (
    id BIGINT PRIMARY KEY,
    user_id VARCHAR(32),
    content_id VARCHAR(32),
    content_type VARCHAR(50),
    action_type ENUM('view', 'share', 'like', 'comment'),
    duration INT,
    completion_rate DECIMAL(5,2),
    created_at TIMESTAMP,
    INDEX idx_user_content (user_id, content_type, created_at),
    INDEX idx_content_action (content_id, action_type, created_at)
);
```

## 2. 核心指标体系

### 2.1 北极星指标
**月度活跃付费用户数（Monthly Active Paying Users）**
- 定义：当月至少有一次付费行为的活跃用户数
- 意义：综合反映产品价值和商业健康度
- 目标：第一年达到5万MAPU

### 2.2 关键指标层级

#### 一级指标（CEO关注）
```
【增长指标】
- MAU：月活跃用户数
- 新用户增长率：月新增用户增长率
- 用户获取成本（CAC）：平均获客成本

【变现指标】
- 月收入（MRR）：月度经常性收入
- 付费转化率：测试完成用户的付费比例
- 客单价（ARPU）：平均每用户收入

【留存指标】
- 次日留存率：新用户次日回访比例
- 月留存率：用户一个月后的留存比例
- 用户生命周期价值（LTV）：用户全生命周期价值
```

#### 二级指标（产品经理关注）
```
【产品使用指标】
- 测试完成率：开始测试用户的完成比例
- 平均测试时长：用户完成测试的平均时间
- 结果页停留时长：用户在结果页的平均停留时间
- 内容消费深度：用户查看内容的平均深度

【用户行为指标】
- 分享率：用户分享测试结果的比例
- 重复测试率：用户再次进行测试的比例
- 社群参与率：用户加入和参与社群的比例
- 客服咨询率：用户主动咨询的比例
```

#### 三级指标（运营关注）
```
【渠道效果指标】
- 各渠道流量占比：不同来源渠道的流量分布
- 各渠道转化率：不同渠道的转化效果对比
- 各渠道获客成本：不同渠道的平均获客成本
- 各渠道用户质量：不同渠道用户的留存和付费表现

【内容运营指标】
- 内容阅读完成率：用户阅读内容的完成比例
- 内容分享率：用户分享内容的比例
- 内容点赞率：用户对内容的点赞比例
- 内容收藏率：用户收藏内容的比例
```

### 2.3 指标计算公式

#### 关键转化率计算
```javascript
// 测试完成率
const testCompletionRate = (completedTests, startedTests) => {
  return (completedTests / startedTests * 100).toFixed(2);
};

// 付费转化率
const paymentConversionRate = (paidUsers, testCompletedUsers) => {
  return (paidUsers / testCompletedUsers * 100).toFixed(2);
};

// 用户留存率
const retentionRate = (returnUsers, totalUsers, days) => {
  return (returnUsers / totalUsers * 100).toFixed(2);
};

// LTV计算
const calculateLTV = (averageRevenue, retentionRate, churnRate) => {
  return averageRevenue / churnRate;
};

// CAC计算
const calculateCAC = (marketingCost, newUsersAcquired) => {
  return (marketingCost / newUsersAcquired).toFixed(2);
};
```

## 3. 实时监控体系

### 3.1 实时大盘设计

#### 核心指标大盘
```
【今日概览】
┌─────────────────┬─────────────────┬─────────────────┐
│   今日新增用户   │    测试完成数    │    付费转化数    │
│      1,234      │      5,678      │       89       │
│   ↑12.3%       │   ↓2.1%        │   ↑45.6%      │
└─────────────────┴─────────────────┴─────────────────┘

【实时趋势】
- 过去24小时用户访问趋势图
- 过去7天关键指标对比图
- 实时转化漏斗展示

【异常监控】
- 转化率异常提醒（低于阈值）
- 流量异常提醒（突增或突降）
- 支付异常提醒（支付失败率过高）
```

#### 渠道效果监控
```
【渠道流量分布】
有机搜索: 35% ████████████████████
社交媒体: 28% ████████████████
付费广告: 20% ████████████
直接访问: 12% ████████
其他渠道: 5%  ████

【渠道质量对比】
渠道      转化率   留存率   LTV    ROI
搜索      15.2%   45.3%   ¥89   320%
社交      12.8%   38.7%   ¥76   280%
广告      18.5%   35.2%   ¥82   250%
直接      22.1%   52.6%   ¥95   ∞
```

### 3.2 预警机制设计

#### 自动预警规则
```javascript
// 预警配置
const alertRules = {
  // 流量异常
  trafficDrop: {
    metric: 'daily_visitors',
    threshold: -30, // 下降超过30%
    timeWindow: '1hour',
    severity: 'high'
  },
  
  // 转化率异常
  conversionDrop: {
    metric: 'payment_conversion_rate',
    threshold: -20, // 下降超过20%
    timeWindow: '4hours',
    severity: 'critical'
  },
  
  // 错误率异常
  errorRateHigh: {
    metric: 'error_rate',
    threshold: 5, // 超过5%
    timeWindow: '15minutes',
    severity: 'high'
  },
  
  // 支付失败率异常
  paymentFailureHigh: {
    metric: 'payment_failure_rate',
    threshold: 10, // 超过10%
    timeWindow: '30minutes',
    severity: 'critical'
  }
};

// 预警通知
const sendAlert = (rule, currentValue, threshold) => {
  const message = `⚠️ ${rule.metric} 异常
当前值: ${currentValue}
阈值: ${threshold}
时间: ${new Date().toLocaleString()}
级别: ${rule.severity}`;
  
  // 发送到企业微信
  sendToWeWork(message);
  
  // 发送邮件通知
  sendEmail(message);
  
  // 记录到监控系统
  logAlert(rule, currentValue);
};
```

## 4. 用户分析体系

### 4.1 用户分群策略

#### RFM用户分群
```sql
-- 用户RFM分析
WITH user_rfm AS (
  SELECT 
    user_id,
    DATEDIFF(CURDATE(), MAX(last_active_date)) as recency,
    COUNT(DISTINCT DATE(created_at)) as frequency,
    SUM(payment_amount) as monetary
  FROM user_activity_summary
  WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
  GROUP BY user_id
),
rfm_scores AS (
  SELECT 
    user_id,
    CASE 
      WHEN recency <= 7 THEN 5
      WHEN recency <= 14 THEN 4
      WHEN recency <= 30 THEN 3
      WHEN recency <= 60 THEN 2
      ELSE 1
    END as r_score,
    CASE 
      WHEN frequency >= 10 THEN 5
      WHEN frequency >= 6 THEN 4
      WHEN frequency >= 4 THEN 3
      WHEN frequency >= 2 THEN 2
      ELSE 1
    END as f_score,
    CASE 
      WHEN monetary >= 200 THEN 5
      WHEN monetary >= 100 THEN 4
      WHEN monetary >= 60 THEN 3
      WHEN monetary >= 30 THEN 2
      ELSE 1
    END as m_score
  FROM user_rfm
)
SELECT 
  user_id,
  CONCAT(r_score, f_score, m_score) as rfm_segment,
  CASE 
    WHEN CONCAT(r_score, f_score, m_score) IN ('555', '554', '544', '545', '454', '455', '445') 
      THEN 'Champions'
    WHEN CONCAT(r_score, f_score, m_score) IN ('543', '444', '435', '355', '354', '345', '344', '335')
      THEN 'Loyal Customers'
    WHEN CONCAT(r_score, f_score, m_score) IN ('512', '511', '422', '421', '412', '411', '311')
      THEN 'Potential Loyalists'
    WHEN CONCAT(r_score, f_score, m_score) IN ('255', '254', '245', '244', '253', '252', '243', '242')
      THEN 'At Risk'
    ELSE 'Others'
  END as segment_name
FROM rfm_scores;
```

#### 行为分群模型
```
【高价值用户】
- 测试完成率 > 90%
- 付费金额 > 100元
- 活跃天数 > 30天
- 分享次数 > 5次

【潜力用户】  
- 测试完成率 > 80%
- 结果页停留 > 5分钟
- 未付费但查看付费内容
- 社交分享行为

【流失风险用户】
- 最后访问 > 14天
- 测试未完成
- 结果页停留 < 2分钟
- 无社交行为

【新手用户】
- 注册 < 7天
- 首次测试用户
- 无付费行为
- 需要引导激活
```

### 4.2 用户生命周期分析

#### 生命周期阶段定义
```javascript
const userLifecycleStages = {
  // 访客阶段
  visitor: {
    definition: '访问网站但未注册',
    keyActions: ['页面浏览', '测试开始'],
    duration: '0-1天',
    conversionGoal: '完成测试'
  },
  
  // 新用户阶段
  newUser: {
    definition: '完成测试但未付费',
    keyActions: ['查看结果', '浏览内容', '分享'],
    duration: '1-7天',
    conversionGoal: '首次付费'
  },
  
  // 活跃用户阶段
  activeUser: {
    definition: '有付费行为且持续使用',
    keyActions: ['查看解析', '参与社群', '重复测试'],
    duration: '7-30天',
    conversionGoal: '成为忠实用户'
  },
  
  // 忠实用户阶段
  loyalUser: {
    definition: '多次付费且高频使用',
    keyActions: ['推荐朋友', '内容创作', '深度参与'],
    duration: '30天以上',
    conversionGoal: '品牌推广者'
  },
  
  // 流失用户阶段
  churnedUser: {
    definition: '长期未访问的用户',
    keyActions: ['无'],
    duration: '30天以上未活跃',
    conversionGoal: '重新激活'
  }
};
```

#### 生命周期价值分析
```sql
-- 用户生命周期价值分析
SELECT 
  lifecycle_stage,
  COUNT(*) as user_count,
  AVG(total_revenue) as avg_revenue,
  AVG(active_days) as avg_active_days,
  AVG(total_revenue / active_days) as daily_value,
  SUM(total_revenue) as total_contribution
FROM (
  SELECT 
    u.user_id,
    CASE 
      WHEN u.registration_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY) 
        AND p.first_payment_date IS NULL THEN 'new_user'
      WHEN p.first_payment_date IS NOT NULL 
        AND u.last_active_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY) THEN 'active_user'
      WHEN p.payment_count >= 3 
        AND u.last_active_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY) THEN 'loyal_user'
      WHEN u.last_active_date < DATE_SUB(CURDATE(), INTERVAL 30 DAY) THEN 'churned_user'
      ELSE 'visitor'
    END as lifecycle_stage,
    COALESCE(p.total_revenue, 0) as total_revenue,
    DATEDIFF(COALESCE(u.last_active_date, u.registration_date), u.registration_date) + 1 as active_days
  FROM users u
  LEFT JOIN (
    SELECT 
      user_id,
      MIN(created_at) as first_payment_date,
      COUNT(*) as payment_count,
      SUM(amount) as total_revenue
    FROM payments 
    WHERE status = 'success'
    GROUP BY user_id
  ) p ON u.user_id = p.user_id
) user_lifecycle
GROUP BY lifecycle_stage;
```

## 5. 产品分析体系

### 5.1 功能使用分析

#### 功能漏斗分析
```sql
-- 核心功能使用漏斗
WITH funnel_data AS (
  SELECT 
    DATE(created_at) as date,
    COUNT(DISTINCT CASE WHEN event_name = 'page_view' AND page_name = 'home' THEN user_id END) as home_visitors,
    COUNT(DISTINCT CASE WHEN event_name = 'click' AND element = 'start_test' THEN user_id END) as test_starters,
    COUNT(DISTINCT CASE WHEN event_name = 'test_completed' THEN user_id END) as test_completers,
    COUNT(DISTINCT CASE WHEN event_name = 'result_viewed' THEN user_id END) as result_viewers,
    COUNT(DISTINCT CASE WHEN event_name = 'payment_initiated' THEN user_id END) as payment_initiators,
    COUNT(DISTINCT CASE WHEN event_name = 'payment_completed' THEN user_id END) as payment_completers
  FROM user_events 
  WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
  GROUP BY DATE(created_at)
)
SELECT 
  date,
  home_visitors,
  test_starters,
  ROUND(test_starters / home_visitors * 100, 2) as start_rate,
  test_completers,
  ROUND(test_completers / test_starters * 100, 2) as completion_rate,
  result_viewers,
  ROUND(result_viewers / test_completers * 100, 2) as view_rate,
  payment_initiators,
  ROUND(payment_initiators / result_viewers * 100, 2) as payment_intent_rate,
  payment_completers,
  ROUND(payment_completers / payment_initiators * 100, 2) as payment_success_rate
FROM funnel_data
ORDER BY date DESC;
```

#### A/B测试分析框架
```javascript
// A/B测试结果分析
class ABTestAnalyzer {
  constructor(testName, variants) {
    this.testName = testName;
    this.variants = variants;
  }
  
  async getTestResults() {
    const results = {};
    
    for (const variant of this.variants) {
      const data = await this.getVariantData(variant);
      results[variant] = {
        users: data.totalUsers,
        conversions: data.conversions,
        conversionRate: (data.conversions / data.totalUsers * 100).toFixed(2),
        revenue: data.revenue,
        revenuePerUser: (data.revenue / data.totalUsers).toFixed(2)
      };
    }
    
    return results;
  }
  
  calculateStatisticalSignificance(variantA, variantB) {
    // 计算统计显著性
    const n1 = variantA.users;
    const n2 = variantB.users;
    const p1 = variantA.conversions / n1;
    const p2 = variantB.conversions / n2;
    
    const pooledP = (variantA.conversions + variantB.conversions) / (n1 + n2);
    const se = Math.sqrt(pooledP * (1 - pooledP) * (1/n1 + 1/n2));
    const zScore = (p1 - p2) / se;
    const pValue = this.calculatePValue(zScore);
    
    return {
      isSignificant: pValue < 0.05,
      pValue: pValue,
      confidenceLevel: (1 - pValue) * 100
    };
  }
}
```

### 5.2 内容效果分析

#### 内容消费分析
```sql
-- 内容消费深度分析
SELECT 
  c.content_type,
  c.content_title,
  COUNT(DISTINCT cc.user_id) as viewers,
  AVG(cc.duration) as avg_view_duration,
  AVG(cc.completion_rate) as avg_completion_rate,
  COUNT(CASE WHEN cc.action_type = 'share' THEN 1 END) as shares,
  COUNT(CASE WHEN cc.action_type = 'like' THEN 1 END) as likes,
  ROUND(COUNT(CASE WHEN cc.action_type = 'share' THEN 1 END) / COUNT(DISTINCT cc.user_id) * 100, 2) as share_rate
FROM content c
LEFT JOIN fact_content_consumption cc ON c.content_id = cc.content_id
WHERE c.created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY c.content_type, c.content_title
ORDER BY viewers DESC;
```

#### 付费内容转化分析
```sql
-- 付费内容解锁分析
SELECT 
  content_module,
  COUNT(DISTINCT user_id) as preview_users,
  COUNT(DISTINCT CASE WHEN is_paid = 1 THEN user_id END) as paid_users,
  ROUND(COUNT(DISTINCT CASE WHEN is_paid = 1 THEN user_id END) / COUNT(DISTINCT user_id) * 100, 2) as conversion_rate,
  AVG(CASE WHEN is_paid = 1 THEN viewing_duration END) as avg_paid_duration,
  AVG(CASE WHEN is_paid = 0 THEN viewing_duration END) as avg_free_duration
FROM content_access_log
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY content_module
ORDER BY conversion_rate DESC;
```

## 6. 商业分析体系

### 6.1 收入分析模型

#### 收入归因分析
```javascript
// 收入归因分析
const revenueAttribution = {
  // 首次接触归因
  firstTouch: {
    definition: '将收入归因于用户第一次接触的渠道',
    useCase: '了解哪个渠道最善于获取新用户',
    calculation: (userJourney) => {
      return userJourney.touchpoints[0].channel;
    }
  },
  
  // 最后接触归因
  lastTouch: {
    definition: '将收入归因于用户最后接触的渠道',
    useCase: '了解哪个渠道最善于转化用户',
    calculation: (userJourney) => {
      return userJourney.touchpoints[userJourney.touchpoints.length - 1].channel;
    }
  },
  
  // 线性归因
  linear: {
    definition: '将收入平均分配给用户旅程中的所有接触点',
    useCase: '了解整个用户旅程的贡献',
    calculation: (userJourney, revenue) => {
      const weight = 1 / userJourney.touchpoints.length;
      return userJourney.touchpoints.map(tp => ({
        channel: tp.channel,
        attribution: revenue * weight
      }));
    }
  },
  
  // 时间衰减归因
  timeDecay: {
    definition: '距离转化时间越近的接触点获得更多归因',
    useCase: '强调转化前的关键接触点',
    calculation: (userJourney, revenue) => {
      const totalWeight = userJourney.touchpoints.reduce((sum, tp, index) => {
        return sum + Math.pow(2, index);
      }, 0);
      
      return userJourney.touchpoints.map((tp, index) => ({
        channel: tp.channel,
        attribution: revenue * (Math.pow(2, index) / totalWeight)
      }));
    }
  }
};
```

#### 收入预测模型
```sql
-- 月度收入预测
WITH historical_data AS (
  SELECT 
    DATE_FORMAT(created_at, '%Y-%m') as month,
    COUNT(DISTINCT user_id) as new_users,
    SUM(amount) as revenue,
    AVG(amount) as avg_order_value
  FROM payments 
  WHERE status = 'success'
    AND created_at >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH)
  GROUP BY DATE_FORMAT(created_at, '%Y-%m')
),
trend_analysis AS (
  SELECT 
    month,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY month) as prev_month_revenue,
    (revenue - LAG(revenue, 1) OVER (ORDER BY month)) / LAG(revenue, 1) OVER (ORDER BY month) * 100 as growth_rate
  FROM historical_data
)
SELECT 
  month,
  revenue,
  growth_rate,
  AVG(growth_rate) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as avg_growth_rate,
  revenue * (1 + AVG(growth_rate) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) / 100) as predicted_next_month
FROM trend_analysis
ORDER BY month;
```

### 6.2 用户价值分析

#### LTV预测模型
```python
# 用户生命周期价值预测
import pandas as pd
from sklearn.ensemble import RandomForestRegressor

class LTVPredictor:
    def __init__(self):
        self.model = RandomForestRegressor(n_estimators=100)
        
    def prepare_features(self, user_data):
        features = pd.DataFrame({
            'days_since_registration': user_data['days_since_registration'],
            'total_sessions': user_data['total_sessions'],
            'avg_session_duration': user_data['avg_session_duration'],
            'test_completion_rate': user_data['test_completion_rate'],
            'content_engagement_score': user_data['content_engagement_score'],
            'social_shares': user_data['social_shares'],
            'customer_service_interactions': user_data['customer_service_interactions'],
            'acquisition_channel': pd.get_dummies(user_data['acquisition_channel']),
            'mbti_type': pd.get_dummies(user_data['mbti_type']),
            'age_group': pd.get_dummies(user_data['age_group'])
        })
        return features
        
    def train(self, training_data):
        X = self.prepare_features(training_data)
        y = training_data['actual_ltv']
        self.model.fit(X, y)
        
    def predict(self, user_data):
        X = self.prepare_features(user_data)
        predicted_ltv = self.model.predict(X)
        return predicted_ltv
        
    def get_feature_importance(self):
        feature_names = self.model.feature_names_in_
        importance = self.model.feature_importances_
        return dict(zip(feature_names, importance))
```

#### 用户分层价值分析
```sql
-- 用户价值分层分析
WITH user_value_metrics AS (
  SELECT 
    u.user_id,
    u.registration_date,
    DATEDIFF(CURDATE(), u.registration_date) as days_since_registration,
    COUNT(DISTINCT s.session_id) as total_sessions,
    COUNT(DISTINCT CASE WHEN p.status = 'success' THEN p.payment_id END) as successful_payments,
    COALESCE(SUM(p.amount), 0) as total_revenue,
    COUNT(DISTINCT t.test_id) as total_tests,
    COUNT(DISTINCT sh.share_id) as total_shares,
    CASE 
      WHEN COALESCE(SUM(p.amount), 0) >= 200 THEN 'High Value'
      WHEN COALESCE(SUM(p.amount), 0) >= 60 THEN 'Medium Value'
      WHEN COALESCE(SUM(p.amount), 0) > 0 THEN 'Low Value'
      ELSE 'No Value'
    END as value_segment
  FROM users u
  LEFT JOIN sessions s ON u.user_id = s.user_id
  LEFT JOIN payments p ON u.user_id = p.user_id
  LEFT JOIN tests t ON u.user_id = t.user_id
  LEFT JOIN shares sh ON u.user_id = sh.user_id
  GROUP BY u.user_id, u.registration_date
)
SELECT 
  value_segment,
  COUNT(*) as user_count,
  ROUND(COUNT(*) / (SELECT COUNT(*) FROM user_value_metrics) * 100, 2) as percentage,
  AVG(total_revenue) as avg_revenue,
  AVG(total_sessions) as avg_sessions,
  AVG(total_tests) as avg_tests,
  AVG(total_shares) as avg_shares,
  AVG(days_since_registration) as avg_days_active
FROM user_value_metrics
GROUP BY value_segment
ORDER BY avg_revenue DESC;
```

## 7. 报表自动化系统

### 7.1 日报系统
```javascript
// 每日数据报表自动生成
const generateDailyReport = async () => {
  const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
  
  const metrics = {
    // 核心指标
    newUsers: await getNewUsers(yesterday),
    activeUsers: await getActiveUsers(yesterday),
    testCompletions: await getTestCompletions(yesterday),
    payments: await getPayments(yesterday),
    revenue: await getRevenue(yesterday),
    
    // 同比数据
    newUsersWoW: await getNewUsersWoW(yesterday),
    revenueWoW: await getRevenueWoW(yesterday),
    
    // 渠道数据
    channelBreakdown: await getChannelBreakdown(yesterday),
    
    // 异常监控
    alerts: await getAlerts(yesterday)
  };
  
  const report = generateReportTemplate(metrics);
  
  // 发送到企业微信群
  await sendToWeWork(report);
  
  // 发送邮件给相关人员
  await sendEmail('daily-report@company.com', 'MBTI产品日报', report);
  
  // 保存到数据库
  await saveReportToDatabase(report, 'daily');
};

// 每天早上9点自动执行
schedule.scheduleJob('0 9 * * *', generateDailyReport);
```

### 7.2 可视化看板
```javascript
// Dashboard 数据API
const dashboardAPI = {
  // 实时核心指标
  getRealTimeMetrics: async () => {
    return {
      currentOnlineUsers: await getCurrentOnlineUsers(),
      todayNewUsers: await getTodayNewUsers(),
      todayRevenue: await getTodayRevenue(),
      testInProgress: await getTestsInProgress()
    };
  },
  
  // 趋势图数据
  getTrendData: async (metric, timeRange) => {
    const data = await getTimeSeriesData(metric, timeRange);
    return {
      labels: data.map(d => d.date),
      values: data.map(d => d.value),
      change: calculateChange(data)
    };
  },
  
  // 漏斗转化数据
  getFunnelData: async (timeRange) => {
    return {
      visitors: await getVisitors(timeRange),
      testStarters: await getTestStarters(timeRange),
      testCompleters: await getTestCompleters(timeRange),
      paymentInitiators: await getPaymentInitiators(timeRange),
      paymentCompleters: await getPaymentCompleters(timeRange)
    };
  },
  
  // 用户分布数据
  getUserDistribution: async () => {
    return {
      byMBTI: await getUsersByMBTI(),
      byAge: await getUsersByAge(),
      byGender: await getUsersByGender(),
      byCity: await getUsersByCity()
    };
  }
};
```

## 8. 数据安全与合规

### 8.1 数据脱敏策略
```javascript
// 敏感数据脱敏
const dataMasking = {
  // 手机号脱敏
  maskPhone: (phone) => {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  },
  
  // 邮箱脱敏
  maskEmail: (email) => {
    const [username, domain] = email.split('@');
    const maskedUsername = username.charAt(0) + '*'.repeat(username.length - 2) + username.charAt(username.length - 1);
    return `${maskedUsername}@${domain}`;
  },
  
  // 用户ID脱敏
  maskUserId: (userId) => {
    return userId.substring(0, 4) + '*'.repeat(userId.length - 8) + userId.substring(userId.length - 4);
  },
  
  // 测试结果脱敏（用于分析）
  maskTestResults: (results) => {
    return {
      mbtiType: results.mbtiType, // 保留类型用于分析
      userId: this.maskUserId(results.userId),
      timestamp: results.timestamp,
      // 移除具体答案内容
      answersHash: md5(JSON.stringify(results.answers))
    };
  }
};
```

### 8.2 数据保留策略
```sql
-- 数据生命周期管理
-- 用户行为数据保留2年
CREATE EVENT delete_old_user_events
ON SCHEDULE EVERY 1 DAY
DO
  DELETE FROM user_events 
  WHERE created_at < DATE_SUB(CURDATE(), INTERVAL 2 YEAR);

-- 系统日志保留6个月  
CREATE EVENT delete_old_system_logs
ON SCHEDULE EVERY 1 WEEK
DO
  DELETE FROM system_logs 
  WHERE created_at < DATE_SUB(CURDATE(), INTERVAL 6 MONTH);

-- 临时数据保留7天
CREATE EVENT delete_temp_data
ON SCHEDULE EVERY 1 DAY
DO
  DELETE FROM temp_analysis_data 
  WHERE created_at < DATE_SUB(CURDATE(), INTERVAL 7 DAY);
```

## 9. 数据团队建设

### 9.1 团队组织架构
```
【数据团队】(6人)
├── 数据产品经理 (1人)
│   ├── 数据需求分析
│   ├── 数据产品规划
│   └── 跨团队协调
├── 数据工程师 (2人)
│   ├── 数据采集和清洗
│   ├── 数据仓库建设
│   └── 数据管道维护
├── 数据分析师 (2人)
│   ├── 业务数据分析
│   ├── 用户行为分析
│   └── 运营效果分析
└── 算法工程师 (1人)
    ├── 推荐算法开发
    ├── 预测模型建设
    └── 机器学习应用
```

### 9.2 数据文化建设
- **数据驱动决策**：所有重要决策都需要数据支撑
- **数据民主化**：让更多员工能够自助获取数据
- **数据质量意识**：建立数据质量检查机制
- **隐私保护意识**：严格遵守数据安全规范

### 9.3 技能培训计划
- **SQL培训**：让运营和产品人员掌握基础查询
- **数据可视化培训**：学会使用BI工具制作报表
- **统计学基础**：理解A/B测试和统计显著性
- **数据安全培训**：了解数据脱敏和合规要求